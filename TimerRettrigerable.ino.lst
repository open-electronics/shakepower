
C:\Users\mirko\AppData\Local\Temp\arduino_build_138370/TimerRettrigerable.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
   0:	21 c0       	rjmp	.+66     	; 0x44 <__ctors_end>
   2:	45 c0       	rjmp	.+138    	; 0x8e <__bad_interrupt>
   4:	ea c1       	rjmp	.+980    	; 0x3da <__vector_2>
   6:	43 c0       	rjmp	.+134    	; 0x8e <__bad_interrupt>
   8:	42 c0       	rjmp	.+132    	; 0x8e <__bad_interrupt>
   a:	9d c1       	rjmp	.+826    	; 0x346 <__vector_5>
   c:	40 c0       	rjmp	.+128    	; 0x8e <__bad_interrupt>
   e:	3f c0       	rjmp	.+126    	; 0x8e <__bad_interrupt>
  10:	3e c0       	rjmp	.+124    	; 0x8e <__bad_interrupt>
  12:	3d c0       	rjmp	.+122    	; 0x8e <__bad_interrupt>
  14:	3c c0       	rjmp	.+120    	; 0x8e <__bad_interrupt>
  16:	3b c0       	rjmp	.+118    	; 0x8e <__bad_interrupt>
  18:	3a c0       	rjmp	.+116    	; 0x8e <__bad_interrupt>
  1a:	39 c0       	rjmp	.+114    	; 0x8e <__bad_interrupt>
  1c:	38 c0       	rjmp	.+112    	; 0x8e <__bad_interrupt>

0000001e <__trampolines_end>:
__trampolines_start():
  1e:	00 00       	nop
  20:	00 00       	nop
  22:	37 00       	.word	0x0037	; ????

00000024 <port_to_output_PGM>:
  24:	00 00 00 00 38 00                                   ....8.

0000002a <digital_pin_to_timer_PGM>:
  2a:	01 03 00 00 04 00                                   ......

00000030 <port_to_input_PGM>:
  30:	00 00 00 00 36 00                                   ....6.

00000036 <digital_pin_to_port_PGM>:
  36:	02 02 02 02 02 02                                   ......

0000003c <digital_pin_to_bit_mask_PGM>:
  3c:	01 02 04 08 10 20                                   ..... 

00000042 <__ctors_start>:
__ctors_start():
  42:	df 03       	fmulsu	r21, r23

00000044 <__ctors_end>:
__dtors_end():
  44:	11 24       	eor	r1, r1
  46:	1f be       	out	0x3f, r1	; 63
  48:	cf e5       	ldi	r28, 0x5F	; 95
  4a:	d2 e0       	ldi	r29, 0x02	; 2
  4c:	de bf       	out	0x3e, r29	; 62
  4e:	cd bf       	out	0x3d, r28	; 61

00000050 <__do_copy_data>:
__do_copy_data():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
  50:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
  52:	a0 e6       	ldi	r26, 0x60	; 96
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
  54:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
  56:	e8 e4       	ldi	r30, 0x48	; 72
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
  58:	f8 e0       	ldi	r31, 0x08	; 8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
  5a:	02 c0       	rjmp	.+4      	; 0x60 <__do_copy_data+0x10>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
  5c:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
  5e:	0d 92       	st	X+, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
  60:	a2 37       	cpi	r26, 0x72	; 114
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
  62:	b1 07       	cpc	r27, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
  64:	d9 f7       	brne	.-10     	; 0x5c <__do_copy_data+0xc>

00000066 <__do_clear_bss>:
__do_clear_bss():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  66:	20 e0       	ldi	r18, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  68:	a2 e7       	ldi	r26, 0x72	; 114
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  6a:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  6c:	01 c0       	rjmp	.+2      	; 0x70 <.do_clear_bss_start>

0000006e <.do_clear_bss_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  6e:	1d 92       	st	X+, r1

00000070 <.do_clear_bss_start>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  70:	a2 39       	cpi	r26, 0x92	; 146
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  72:	b2 07       	cpc	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  74:	e1 f7       	brne	.-8      	; 0x6e <.do_clear_bss_loop>

00000076 <__do_global_ctors>:
__do_global_ctors():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
  76:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
  78:	c2 e2       	ldi	r28, 0x22	; 34
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
  7a:	d0 e0       	ldi	r29, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
  7c:	03 c0       	rjmp	.+6      	; 0x84 <__do_global_ctors+0xe>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
  7e:	21 97       	sbiw	r28, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
  80:	fe 01       	movw	r30, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
  82:	da d3       	rcall	.+1972   	; 0x838 <__tablejump2__>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
  84:	c1 32       	cpi	r28, 0x21	; 33
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
  86:	d1 07       	cpc	r29, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
  88:	d1 f7       	brne	.-12     	; 0x7e <__do_global_ctors+0x8>
  8a:	00 d2       	rcall	.+1024   	; 0x48c <main>
  8c:	db c3       	rjmp	.+1974   	; 0x844 <_exit>

0000008e <__bad_interrupt>:
__vector_1():
  8e:	b8 cf       	rjmp	.-144    	; 0x0 <__vectors>

00000090 <micros>:
micros():
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:360
    unsigned int r; // needed for some frequencies, optimized away otherwise
    unsigned char f; // temporary storage for millis fraction counter
    unsigned char q = 0; // record whether an overflow is flagged
#endif
    unsigned long m;
    uint8_t t, oldSREG = SREG;
  90:	3f b7       	in	r19, 0x3f	; 63
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:362

    cli();
  92:	f8 94       	cli
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:367
#ifdef CORRECT_EXACT_MICROS
    m = millis_timer_millis;
    f = millis_timer_fract;
#else
    m = millis_timer_overflow_count;
  94:	80 91 77 00 	lds	r24, 0x0077	; 0x800077 <millis_timer_overflow_count>
  98:	90 91 78 00 	lds	r25, 0x0078	; 0x800078 <millis_timer_overflow_count+0x1>
  9c:	a0 91 79 00 	lds	r26, 0x0079	; 0x800079 <millis_timer_overflow_count+0x2>
  a0:	b0 91 7a 00 	lds	r27, 0x007A	; 0x80007a <millis_timer_overflow_count+0x3>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:370
#endif
  #if defined(TCNT0) && (TIMER_TO_USE_FOR_MILLIS == 0) && !defined(TCW0)
    t = TCNT0;
  a4:	22 b7       	in	r18, 0x32	; 50
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:389
      m++;
    #else
      q = 1;
    #endif
  #elif defined(TIFR) && (TIMER_TO_USE_FOR_MILLIS == 0)
    if ((TIFR & _BV(TOV0)) && (t < 255))
  a6:	08 b6       	in	r0, 0x38	; 56
  a8:	01 fe       	sbrs	r0, 1
  aa:	05 c0       	rjmp	.+10     	; 0xb6 <micros+0x26>
  ac:	2f 3f       	cpi	r18, 0xFF	; 255
  ae:	19 f0       	breq	.+6      	; 0xb6 <micros+0x26>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:391
    #ifndef CORRECT_EXACT_MICROS
      m++;
  b0:	01 96       	adiw	r24, 0x01	; 1
  b2:	a1 1d       	adc	r26, r1
  b4:	b1 1d       	adc	r27, r1
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:411
    #else
      q = 1;
    #endif
  #endif

    SREG = oldSREG;
  b6:	3f bf       	out	0x3f, r19	; 63
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:453
  #else
  #if F_CPU < 1000000L
    return ((m << 8) + t) * MillisTimer_Prescale_Value * (1000000L/F_CPU);
  #else
    #if (MillisTimer_Prescale_Value % clockCyclesPerMicrosecond() == 0 && (F_CPU % 1000000 == 0 )) // Can we just do it the naive way? If so great!
      return ((m << 8) + t) * (MillisTimer_Prescale_Value / clockCyclesPerMicrosecond());
  b8:	ba 2f       	mov	r27, r26
  ba:	a9 2f       	mov	r26, r25
  bc:	98 2f       	mov	r25, r24
  be:	88 27       	eor	r24, r24
  c0:	bc 01       	movw	r22, r24
  c2:	cd 01       	movw	r24, r26
  c4:	62 0f       	add	r22, r18
  c6:	71 1d       	adc	r23, r1
  c8:	81 1d       	adc	r24, r1
  ca:	91 1d       	adc	r25, r1
  cc:	43 e0       	ldi	r20, 0x03	; 3
  ce:	66 0f       	add	r22, r22
  d0:	77 1f       	adc	r23, r23
  d2:	88 1f       	adc	r24, r24
  d4:	99 1f       	adc	r25, r25
  d6:	4a 95       	dec	r20
  d8:	d1 f7       	brne	.-12     	; 0xce <micros+0x3e>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:508
      //return ((m << 8 )/clockCyclesPerMicrosecond()* MillisTimer_Prescale_Value) + ((t+(((m<<8)%clockCyclesPerMicrosecond())) * MillisTimer_Prescale_Value / clockCyclesPerMicrosecond()));
      return ((m << 8 )/clockCyclesPerMicrosecond()* MillisTimer_Prescale_Value) + (t * MillisTimer_Prescale_Value / clockCyclesPerMicrosecond());
    #endif
  #endif
  #endif // !CORRECT_EXACT_MICROS
  }
  da:	08 95       	ret

000000dc <delay>:
delay():
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:516
    // Empty
  }
  void yield(void) __attribute__ ((weak, alias("__empty")));

  void delay(unsigned long ms)
  {
  dc:	cf 92       	push	r12
  de:	df 92       	push	r13
  e0:	ef 92       	push	r14
  e2:	ff 92       	push	r15
  e4:	cf 93       	push	r28
  e6:	df 93       	push	r29
  e8:	6b 01       	movw	r12, r22
  ea:	7c 01       	movw	r14, r24
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:518
    #if (F_CPU>=1000000L)
    uint16_t start = (uint16_t)micros();
  ec:	d1 df       	rcall	.-94     	; 0x90 <micros>
  ee:	eb 01       	movw	r28, r22
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:520

    while (ms > 0) {
  f0:	c1 14       	cp	r12, r1
  f2:	d1 04       	cpc	r13, r1
  f4:	e1 04       	cpc	r14, r1
  f6:	f1 04       	cpc	r15, r1
  f8:	41 f4       	brne	.+16     	; 0x10a <delay+0x2e>
  fa:	12 c0       	rjmp	.+36     	; 0x120 <delay+0x44>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:523
      yield();
      while (((uint16_t)micros() - start) >= 1000 && ms) {
        ms--;
  fc:	81 e0       	ldi	r24, 0x01	; 1
  fe:	c8 1a       	sub	r12, r24
 100:	d1 08       	sbc	r13, r1
 102:	e1 08       	sbc	r14, r1
 104:	f1 08       	sbc	r15, r1
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:524
        start += 1000;
 106:	c8 51       	subi	r28, 0x18	; 24
 108:	dc 4f       	sbci	r29, 0xFC	; 252
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:522
    #if (F_CPU>=1000000L)
    uint16_t start = (uint16_t)micros();

    while (ms > 0) {
      yield();
      while (((uint16_t)micros() - start) >= 1000 && ms) {
 10a:	c2 df       	rcall	.-124    	; 0x90 <micros>
 10c:	6c 1b       	sub	r22, r28
 10e:	7d 0b       	sbc	r23, r29
 110:	68 3e       	cpi	r22, 0xE8	; 232
 112:	73 40       	sbci	r23, 0x03	; 3
 114:	68 f3       	brcs	.-38     	; 0xf0 <delay+0x14>
 116:	c1 14       	cp	r12, r1
 118:	d1 04       	cpc	r13, r1
 11a:	e1 04       	cpc	r14, r1
 11c:	f1 04       	cpc	r15, r1
 11e:	71 f7       	brne	.-36     	; 0xfc <delay+0x20>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:532
    #else
    uint32_t start = millis();
    while((millis() - start) < ms)  /* NOP */yield();
    return;
    #endif
  }
 120:	df 91       	pop	r29
 122:	cf 91       	pop	r28
 124:	ff 90       	pop	r15
 126:	ef 90       	pop	r14
 128:	df 90       	pop	r13
 12a:	cf 90       	pop	r12
 12c:	08 95       	ret

0000012e <millis>:
millis():
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:341
  }

  unsigned long millis()
  {
    unsigned long m;
    uint8_t oldSREG = SREG;
 12e:	2f b7       	in	r18, 0x3f	; 63
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:345

    // disable interrupts while we read millis_timer_millis or we might get an
    // inconsistent value (e.g. in the middle of a write to millis_timer_millis)
    cli();
 130:	f8 94       	cli
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:346
    m = millis_timer_millis;
 132:	60 91 73 00 	lds	r22, 0x0073	; 0x800073 <millis_timer_millis>
 136:	70 91 74 00 	lds	r23, 0x0074	; 0x800074 <millis_timer_millis+0x1>
 13a:	80 91 75 00 	lds	r24, 0x0075	; 0x800075 <millis_timer_millis+0x2>
 13e:	90 91 76 00 	lds	r25, 0x0076	; 0x800076 <millis_timer_millis+0x3>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:347
    SREG = oldSREG;
 142:	2f bf       	out	0x3f, r18	; 63
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:350

    return m;
  }
 144:	08 95       	ret

00000146 <irs_sub()>:
_Z7irs_subv():
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:68
} 



void irs_sub(void) {
  power_status  = true;
 146:	81 e0       	ldi	r24, 0x01	; 1
 148:	80 93 8f 00 	sts	0x008F, r24	; 0x80008f <power_status>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:69
  led_tilt_status =true;
 14c:	80 93 8e 00 	sts	0x008E, r24	; 0x80008e <led_tilt_status>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:70
  timer = millis(); 
 150:	ee df       	rcall	.-36     	; 0x12e <millis>
 152:	60 93 86 00 	sts	0x0086, r22	; 0x800086 <timer>
 156:	70 93 87 00 	sts	0x0087, r23	; 0x800087 <timer+0x1>
 15a:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <timer+0x2>
 15e:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <timer+0x3>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:71
  timer_led_tilt = millis();
 162:	e5 df       	rcall	.-54     	; 0x12e <millis>
 164:	60 93 8a 00 	sts	0x008A, r22	; 0x80008a <timer_led_tilt>
 168:	70 93 8b 00 	sts	0x008B, r23	; 0x80008b <timer_led_tilt+0x1>
 16c:	80 93 8c 00 	sts	0x008C, r24	; 0x80008c <timer_led_tilt+0x2>
 170:	90 93 8d 00 	sts	0x008D, r25	; 0x80008d <timer_led_tilt+0x3>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:72
  timer_buzzer = millis(); 
 174:	dc cf       	rjmp	.-72     	; 0x12e <millis>

00000176 <pcint_null_callback>:
pcint_null_callback():
C:\Program Files (x86)\Arduino\libraries\PinChangeInterrupt\src/PinChangeInterrupt.cpp:87

// useless function for weak implemented/not used functions, extern c needed for the alias
extern "C" {
	void pcint_null_callback(void) {
		// useless
	}
 176:	08 95       	ret

00000178 <digitalRead>:
digitalRead():
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:167
  }
}

int digitalRead(uint8_t pin)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
 178:	87 ff       	sbrs	r24, 7
 17a:	09 c0       	rjmp	.+18     	; 0x18e <digitalRead+0x16>
 17c:	8f 77       	andi	r24, 0x7F	; 127
 17e:	01 f1       	breq	.+64     	; 0x1c0 <digitalRead+0x48>
 180:	81 30       	cpi	r24, 0x01	; 1
 182:	01 f1       	breq	.+64     	; 0x1c4 <digitalRead+0x4c>
 184:	82 30       	cpi	r24, 0x02	; 2
 186:	01 f1       	breq	.+64     	; 0x1c8 <digitalRead+0x50>
 188:	83 30       	cpi	r24, 0x03	; 3
 18a:	01 f1       	breq	.+64     	; 0x1cc <digitalRead+0x54>
 18c:	8f ef       	ldi	r24, 0xFF	; 255
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:169
  //uint8_t timer = digitalPinToTimer(pin);
  uint8_t bit = digitalPinToBitMask(pin);
 18e:	90 e0       	ldi	r25, 0x00	; 0
 190:	fc 01       	movw	r30, r24
 192:	e4 5c       	subi	r30, 0xC4	; 196
 194:	ff 4f       	sbci	r31, 0xFF	; 255
 196:	24 91       	lpm	r18, Z
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:170
  uint8_t port = digitalPinToPort(pin);
 198:	fc 01       	movw	r30, r24
 19a:	ea 5c       	subi	r30, 0xCA	; 202
 19c:	ff 4f       	sbci	r31, 0xFF	; 255
 19e:	e4 91       	lpm	r30, Z
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:172

  if (port == NOT_A_PIN) return LOW;
 1a0:	ee 23       	and	r30, r30
 1a2:	b1 f0       	breq	.+44     	; 0x1d0 <digitalRead+0x58>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:180
  // "read" should *NEVER* change the behavior of the thing you're using it on.
  // That's why it's called "read" not "write". As an added bonus, sets the
  // stage for auto-fast-digitalRead() for compile time known pins.
  // if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  if (*portInputRegister(port) & bit) return HIGH;
 1a4:	f0 e0       	ldi	r31, 0x00	; 0
 1a6:	ee 0f       	add	r30, r30
 1a8:	ff 1f       	adc	r31, r31
 1aa:	e0 5d       	subi	r30, 0xD0	; 208
 1ac:	ff 4f       	sbci	r31, 0xFF	; 255
 1ae:	a5 91       	lpm	r26, Z+
 1b0:	b4 91       	lpm	r27, Z
 1b2:	ec 91       	ld	r30, X
 1b4:	e2 23       	and	r30, r18
 1b6:	81 e0       	ldi	r24, 0x01	; 1
 1b8:	90 e0       	ldi	r25, 0x00	; 0
 1ba:	61 f4       	brne	.+24     	; 0x1d4 <digitalRead+0x5c>
 1bc:	80 e0       	ldi	r24, 0x00	; 0
 1be:	08 95       	ret
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:167
  }
}

int digitalRead(uint8_t pin)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
 1c0:	85 e0       	ldi	r24, 0x05	; 5
 1c2:	e5 cf       	rjmp	.-54     	; 0x18e <digitalRead+0x16>
 1c4:	82 e0       	ldi	r24, 0x02	; 2
 1c6:	e3 cf       	rjmp	.-58     	; 0x18e <digitalRead+0x16>
 1c8:	84 e0       	ldi	r24, 0x04	; 4
 1ca:	e1 cf       	rjmp	.-62     	; 0x18e <digitalRead+0x16>
 1cc:	83 e0       	ldi	r24, 0x03	; 3
 1ce:	df cf       	rjmp	.-66     	; 0x18e <digitalRead+0x16>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:172
  //uint8_t timer = digitalPinToTimer(pin);
  uint8_t bit = digitalPinToBitMask(pin);
  uint8_t port = digitalPinToPort(pin);

  if (port == NOT_A_PIN) return LOW;
 1d0:	80 e0       	ldi	r24, 0x00	; 0
 1d2:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:182
  // stage for auto-fast-digitalRead() for compile time known pins.
  // if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  if (*portInputRegister(port) & bit) return HIGH;
  return LOW;
}
 1d4:	08 95       	ret

000001d6 <digitalWrite>:
digitalWrite():
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:139
}

void digitalWrite(uint8_t pin, uint8_t val)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
  uint8_t timer = digitalPinToTimer(pin);
 1d6:	90 e0       	ldi	r25, 0x00	; 0
 1d8:	fc 01       	movw	r30, r24
 1da:	e6 5d       	subi	r30, 0xD6	; 214
 1dc:	ff 4f       	sbci	r31, 0xFF	; 255
 1de:	34 91       	lpm	r19, Z
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:140
  uint8_t bit = digitalPinToBitMask(pin);
 1e0:	fc 01       	movw	r30, r24
 1e2:	e4 5c       	subi	r30, 0xC4	; 196
 1e4:	ff 4f       	sbci	r31, 0xFF	; 255
 1e6:	24 91       	lpm	r18, Z
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:141
  uint8_t port = digitalPinToPort(pin);
 1e8:	fc 01       	movw	r30, r24
 1ea:	ea 5c       	subi	r30, 0xCA	; 202
 1ec:	ff 4f       	sbci	r31, 0xFF	; 255
 1ee:	e4 91       	lpm	r30, Z
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:144
  volatile uint8_t *out;

  if (port == NOT_A_PIN) return;
 1f0:	ee 23       	and	r30, r30
 1f2:	b9 f0       	breq	.+46     	; 0x222 <digitalWrite+0x4c>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:148

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 1f4:	33 23       	and	r19, r19
 1f6:	29 f0       	breq	.+10     	; 0x202 <digitalWrite+0x2c>
turnOffPWM():
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:67
}

static void turnOffPWM(uint8_t timer)
{
  #if defined(TCCR0A) && defined(COM0A1)
    if( timer == TIMER0A){
 1f8:	31 30       	cpi	r19, 0x01	; 1
 1fa:	a1 f4       	brne	.+40     	; 0x224 <digitalWrite+0x4e>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:68
      cbi(TCCR0A, COM0A1);
 1fc:	8a b5       	in	r24, 0x2a	; 42
 1fe:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:74
      //cbi(TCCR0A, COM0A0);
    } else
  #endif
  #if defined(TCCR0A) && defined(COM0B1)
    if( timer == TIMER0B){
      cbi(TCCR0A, COM0B1);
 200:	8a bd       	out	0x2a, r24	; 42
digitalWrite():
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:150

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  out = portOutputRegister(port);
 202:	f0 e0       	ldi	r31, 0x00	; 0
 204:	ee 0f       	add	r30, r30
 206:	ff 1f       	adc	r31, r31
 208:	ec 5d       	subi	r30, 0xDC	; 220
 20a:	ff 4f       	sbci	r31, 0xFF	; 255
 20c:	a5 91       	lpm	r26, Z+
 20e:	b4 91       	lpm	r27, Z
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:153

  if (val == LOW) {
    uint8_t oldSREG = SREG;
 210:	8f b7       	in	r24, 0x3f	; 63
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:152
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  out = portOutputRegister(port);

  if (val == LOW) {
 212:	61 11       	cpse	r22, r1
 214:	18 c0       	rjmp	.+48     	; 0x246 <digitalWrite+0x70>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:154
    uint8_t oldSREG = SREG;
    cli();
 216:	f8 94       	cli
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:155
    *out &= ~bit;
 218:	ec 91       	ld	r30, X
 21a:	20 95       	com	r18
 21c:	2e 23       	and	r18, r30
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:160
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
    cli();
    *out |= bit;
 21e:	2c 93       	st	X, r18
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:161
    SREG = oldSREG;
 220:	8f bf       	out	0x3f, r24	; 63
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:163
  }
}
 222:	08 95       	ret
turnOffPWM():
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:73
      cbi(TCCR0A, COM0A1);
      //cbi(TCCR0A, COM0A0);
    } else
  #endif
  #if defined(TCCR0A) && defined(COM0B1)
    if( timer == TIMER0B){
 224:	32 30       	cpi	r19, 0x02	; 2
 226:	19 f4       	brne	.+6      	; 0x22e <digitalWrite+0x58>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:74
      cbi(TCCR0A, COM0B1);
 228:	8a b5       	in	r24, 0x2a	; 42
 22a:	8f 7d       	andi	r24, 0xDF	; 223
 22c:	e9 cf       	rjmp	.-46     	; 0x200 <digitalWrite+0x2a>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:106
      //cbi(TCCR1C,COM1D0);
    } else
  #else
    // Timer1 for non-x61/x7
    #if defined(TCCR1) && defined(COM1A1) // x5
      if(timer == TIMER1A){
 22e:	33 30       	cpi	r19, 0x03	; 3
 230:	21 f4       	brne	.+8      	; 0x23a <digitalWrite+0x64>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:107
        TCCR1 &= ~(1<<COM1A1);
 232:	80 b7       	in	r24, 0x30	; 48
 234:	8f 7d       	andi	r24, 0xDF	; 223
 236:	80 bf       	out	0x30, r24	; 48
 238:	e4 cf       	rjmp	.-56     	; 0x202 <digitalWrite+0x2c>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:112
        //cbi(TCCR1, COM1A0);
      } else
    #endif
    #if defined(TCCR1) && defined(COM1B1) // x5
      if( timer == TIMER1B){
 23a:	34 30       	cpi	r19, 0x04	; 4
 23c:	11 f7       	brne	.-60     	; 0x202 <digitalWrite+0x2c>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:113
        GTCCR &= ~(1<<COM1B1);
 23e:	8c b5       	in	r24, 0x2c	; 44
 240:	8f 7d       	andi	r24, 0xDF	; 223
 242:	8c bd       	out	0x2c, r24	; 44
 244:	de cf       	rjmp	.-68     	; 0x202 <digitalWrite+0x2c>
digitalWrite():
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:159
    cli();
    *out &= ~bit;
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
    cli();
 246:	f8 94       	cli
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:160
    *out |= bit;
 248:	ec 91       	ld	r30, X
 24a:	2e 2b       	or	r18, r30
 24c:	e8 cf       	rjmp	.-48     	; 0x21e <digitalWrite+0x48>

0000024e <blinkShort()>:
_Z10blinkShortv():
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:100
  digitalWrite(LED2, LOW);
}


void blinkShort(){
  digitalWrite(LED2, HIGH);
 24e:	61 e0       	ldi	r22, 0x01	; 1
 250:	83 e0       	ldi	r24, 0x03	; 3
 252:	c1 df       	rcall	.-126    	; 0x1d6 <digitalWrite>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:101
  delay(100);
 254:	64 e6       	ldi	r22, 0x64	; 100
 256:	70 e0       	ldi	r23, 0x00	; 0
 258:	80 e0       	ldi	r24, 0x00	; 0
 25a:	90 e0       	ldi	r25, 0x00	; 0
 25c:	3f df       	rcall	.-386    	; 0xdc <delay>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:102
  digitalWrite(LED2, LOW);
 25e:	60 e0       	ldi	r22, 0x00	; 0
 260:	83 e0       	ldi	r24, 0x03	; 3
 262:	b9 cf       	rjmp	.-142    	; 0x1d6 <digitalWrite>

00000264 <beepShort()>:
_Z9beepShortv():
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:85
  digitalWrite(BUZZER, LOW);
}


void beepShort(){
  digitalWrite(BUZZER, HIGH);
 264:	61 e0       	ldi	r22, 0x01	; 1
 266:	82 e0       	ldi	r24, 0x02	; 2
 268:	b6 df       	rcall	.-148    	; 0x1d6 <digitalWrite>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:86
  delay(100);
 26a:	64 e6       	ldi	r22, 0x64	; 100
 26c:	70 e0       	ldi	r23, 0x00	; 0
 26e:	80 e0       	ldi	r24, 0x00	; 0
 270:	90 e0       	ldi	r25, 0x00	; 0
 272:	34 df       	rcall	.-408    	; 0xdc <delay>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:87
  digitalWrite(BUZZER, LOW);
 274:	60 e0       	ldi	r22, 0x00	; 0
 276:	82 e0       	ldi	r24, 0x02	; 2
 278:	ae cf       	rjmp	.-164    	; 0x1d6 <digitalWrite>

0000027a <notify_delay() [clone .part.2]>:
_Z12notify_delayv.part.2():
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:106
  delay(100);
  digitalWrite(LED2, LOW);
}


void notify_delay(){
 27a:	cf 93       	push	r28
 27c:	df 93       	push	r29
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:108
 if (n_interval != 255) {
    for(int x = 0; x < n_interval; x++) {
 27e:	d0 e0       	ldi	r29, 0x00	; 0
 280:	c0 e0       	ldi	r28, 0x00	; 0
 282:	80 91 6c 00 	lds	r24, 0x006C	; 0x80006c <n_interval>
 286:	90 91 6d 00 	lds	r25, 0x006D	; 0x80006d <n_interval+0x1>
 28a:	c8 17       	cp	r28, r24
 28c:	d9 07       	cpc	r29, r25
 28e:	48 f4       	brcc	.+18     	; 0x2a2 <notify_delay() [clone .part.2]+0x28>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:109
      beepShort();
 290:	e9 df       	rcall	.-46     	; 0x264 <beepShort()>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:110
      blinkShort();
 292:	dd df       	rcall	.-70     	; 0x24e <blinkShort()>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:111
      delay(1000);  
 294:	68 ee       	ldi	r22, 0xE8	; 232
 296:	73 e0       	ldi	r23, 0x03	; 3
 298:	80 e0       	ldi	r24, 0x00	; 0
 29a:	90 e0       	ldi	r25, 0x00	; 0
 29c:	1f df       	rcall	.-450    	; 0xdc <delay>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:108
}


void notify_delay(){
 if (n_interval != 255) {
    for(int x = 0; x < n_interval; x++) {
 29e:	21 96       	adiw	r28, 0x01	; 1
 2a0:	f0 cf       	rjmp	.-32     	; 0x282 <notify_delay() [clone .part.2]+0x8>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:114
      beepShort();
      blinkShort();
      delay(1000);  
    }
  }  
}
 2a2:	df 91       	pop	r29
 2a4:	cf 91       	pop	r28
 2a6:	08 95       	ret

000002a8 <pinMode>:
pinMode():
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:33
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
 2a8:	cf 93       	push	r28
 2aa:	df 93       	push	r29
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:34
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
 2ac:	87 ff       	sbrs	r24, 7
 2ae:	09 c0       	rjmp	.+18     	; 0x2c2 <pinMode+0x1a>
 2b0:	8f 77       	andi	r24, 0x7F	; 127
 2b2:	71 f1       	breq	.+92     	; 0x310 <pinMode+0x68>
 2b4:	81 30       	cpi	r24, 0x01	; 1
 2b6:	71 f1       	breq	.+92     	; 0x314 <pinMode+0x6c>
 2b8:	82 30       	cpi	r24, 0x02	; 2
 2ba:	71 f1       	breq	.+92     	; 0x318 <pinMode+0x70>
 2bc:	83 30       	cpi	r24, 0x03	; 3
 2be:	71 f1       	breq	.+92     	; 0x31c <pinMode+0x74>
 2c0:	8f ef       	ldi	r24, 0xFF	; 255
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:35
  uint8_t bit = digitalPinToBitMask(pin);
 2c2:	90 e0       	ldi	r25, 0x00	; 0
 2c4:	fc 01       	movw	r30, r24
 2c6:	e4 5c       	subi	r30, 0xC4	; 196
 2c8:	ff 4f       	sbci	r31, 0xFF	; 255
 2ca:	24 91       	lpm	r18, Z
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:36
  uint8_t port = digitalPinToPort(pin);
 2cc:	8a 5c       	subi	r24, 0xCA	; 202
 2ce:	9f 4f       	sbci	r25, 0xFF	; 255
 2d0:	fc 01       	movw	r30, r24
 2d2:	84 91       	lpm	r24, Z
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:39
  volatile uint8_t *reg, *out;

  if (port == NOT_A_PIN) return;
 2d4:	88 23       	and	r24, r24
 2d6:	c9 f0       	breq	.+50     	; 0x30a <pinMode+0x62>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:41

  reg = portModeRegister(port);
 2d8:	90 e0       	ldi	r25, 0x00	; 0
 2da:	88 0f       	add	r24, r24
 2dc:	99 1f       	adc	r25, r25
 2de:	fc 01       	movw	r30, r24
 2e0:	e2 5e       	subi	r30, 0xE2	; 226
 2e2:	ff 4f       	sbci	r31, 0xFF	; 255
 2e4:	a5 91       	lpm	r26, Z+
 2e6:	b4 91       	lpm	r27, Z
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:42
  out = portOutputRegister(port);
 2e8:	fc 01       	movw	r30, r24
 2ea:	ec 5d       	subi	r30, 0xDC	; 220
 2ec:	ff 4f       	sbci	r31, 0xFF	; 255
 2ee:	c5 91       	lpm	r28, Z+
 2f0:	d4 91       	lpm	r29, Z
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:44

  if (mode == INPUT) {
 2f2:	61 11       	cpse	r22, r1
 2f4:	15 c0       	rjmp	.+42     	; 0x320 <pinMode+0x78>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:45
    uint8_t oldSREG = SREG;
 2f6:	9f b7       	in	r25, 0x3f	; 63
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:46
                cli();
 2f8:	f8 94       	cli
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:47
    *reg &= ~bit;
 2fa:	8c 91       	ld	r24, X
 2fc:	20 95       	com	r18
 2fe:	82 23       	and	r24, r18
 300:	8c 93       	st	X, r24
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:48
    *out &= ~bit;
 302:	88 81       	ld	r24, Y
 304:	28 23       	and	r18, r24
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:54
    SREG = oldSREG;
  } else if (mode == INPUT_PULLUP) {
    uint8_t oldSREG = SREG;
                cli();
    *reg &= ~bit;
    *out |= bit;
 306:	28 83       	st	Y, r18
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:55
    SREG = oldSREG;
 308:	9f bf       	out	0x3f, r25	; 63
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:62
    uint8_t oldSREG = SREG;
                cli();
    *reg |= bit;
    SREG = oldSREG;
  }
}
 30a:	df 91       	pop	r29
 30c:	cf 91       	pop	r28
 30e:	08 95       	ret
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:34
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
 310:	85 e0       	ldi	r24, 0x05	; 5
 312:	d7 cf       	rjmp	.-82     	; 0x2c2 <pinMode+0x1a>
 314:	82 e0       	ldi	r24, 0x02	; 2
 316:	d5 cf       	rjmp	.-86     	; 0x2c2 <pinMode+0x1a>
 318:	84 e0       	ldi	r24, 0x04	; 4
 31a:	d3 cf       	rjmp	.-90     	; 0x2c2 <pinMode+0x1a>
 31c:	83 e0       	ldi	r24, 0x03	; 3
 31e:	d1 cf       	rjmp	.-94     	; 0x2c2 <pinMode+0x1a>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:50
    uint8_t oldSREG = SREG;
                cli();
    *reg &= ~bit;
    *out &= ~bit;
    SREG = oldSREG;
  } else if (mode == INPUT_PULLUP) {
 320:	62 30       	cpi	r22, 0x02	; 2
 322:	51 f4       	brne	.+20     	; 0x338 <pinMode+0x90>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:51
    uint8_t oldSREG = SREG;
 324:	9f b7       	in	r25, 0x3f	; 63
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:52
                cli();
 326:	f8 94       	cli
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:53
    *reg &= ~bit;
 328:	3c 91       	ld	r19, X
 32a:	82 2f       	mov	r24, r18
 32c:	80 95       	com	r24
 32e:	83 23       	and	r24, r19
 330:	8c 93       	st	X, r24
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:54
    *out |= bit;
 332:	e8 81       	ld	r30, Y
 334:	2e 2b       	or	r18, r30
 336:	e7 cf       	rjmp	.-50     	; 0x306 <pinMode+0x5e>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:57
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
 338:	8f b7       	in	r24, 0x3f	; 63
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:58
                cli();
 33a:	f8 94       	cli
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:59
    *reg |= bit;
 33c:	ec 91       	ld	r30, X
 33e:	2e 2b       	or	r18, r30
 340:	2c 93       	st	X, r18
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:60
    SREG = oldSREG;
 342:	8f bf       	out	0x3f, r24	; 63
 344:	e2 cf       	rjmp	.-60     	; 0x30a <pinMode+0x62>

00000346 <__vector_5>:
__vector_5():
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:308
      #error "cannot find Millis() timer overflow vector"
    #endif
  #else
    #error "Millis() timer not defined!"
  #endif
  {
 346:	1f 92       	push	r1
 348:	0f 92       	push	r0
 34a:	0f b6       	in	r0, 0x3f	; 63
 34c:	0f 92       	push	r0
 34e:	11 24       	eor	r1, r1
 350:	2f 93       	push	r18
 352:	3f 93       	push	r19
 354:	8f 93       	push	r24
 356:	9f 93       	push	r25
 358:	af 93       	push	r26
 35a:	bf 93       	push	r27
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:311
    // copy these to local variables so they can be stored in registers
    // (volatile variables must be read from memory on every access)
    unsigned long m = millis_timer_millis;
 35c:	80 91 73 00 	lds	r24, 0x0073	; 0x800073 <millis_timer_millis>
 360:	90 91 74 00 	lds	r25, 0x0074	; 0x800074 <millis_timer_millis+0x1>
 364:	a0 91 75 00 	lds	r26, 0x0075	; 0x800075 <millis_timer_millis+0x2>
 368:	b0 91 76 00 	lds	r27, 0x0076	; 0x800076 <millis_timer_millis+0x3>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:312
    unsigned char f = millis_timer_fract;
 36c:	30 91 72 00 	lds	r19, 0x0072	; 0x800072 <__data_end>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:319
    static unsigned char correct_exact = 0;     // rollover intended
    if (++correct_exact < CORRECT_EXACT_MANY) {
      ++f;
    }
#endif
    f += FRACT_INC;
 370:	26 e0       	ldi	r18, 0x06	; 6
 372:	23 0f       	add	r18, r19
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:321

    if (f >= FRACT_MAX)
 374:	2d 37       	cpi	r18, 0x7D	; 125
 376:	68 f1       	brcs	.+90     	; 0x3d2 <__vector_5+0x8c>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:323
    {
      f -= FRACT_MAX;
 378:	29 e8       	ldi	r18, 0x89	; 137
 37a:	23 0f       	add	r18, r19
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:324
      m += MILLIS_INC + 1;
 37c:	03 96       	adiw	r24, 0x03	; 3
 37e:	a1 1d       	adc	r26, r1
 380:	b1 1d       	adc	r27, r1
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:331
    else
    {
      m += MILLIS_INC;
    }

    millis_timer_fract = f;
 382:	20 93 72 00 	sts	0x0072, r18	; 0x800072 <__data_end>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:332
    millis_timer_millis = m;
 386:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <millis_timer_millis>
 38a:	90 93 74 00 	sts	0x0074, r25	; 0x800074 <millis_timer_millis+0x1>
 38e:	a0 93 75 00 	sts	0x0075, r26	; 0x800075 <millis_timer_millis+0x2>
 392:	b0 93 76 00 	sts	0x0076, r27	; 0x800076 <millis_timer_millis+0x3>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:334
#ifndef CORRECT_EXACT_MICROS
    millis_timer_overflow_count++;
 396:	80 91 77 00 	lds	r24, 0x0077	; 0x800077 <millis_timer_overflow_count>
 39a:	90 91 78 00 	lds	r25, 0x0078	; 0x800078 <millis_timer_overflow_count+0x1>
 39e:	a0 91 79 00 	lds	r26, 0x0079	; 0x800079 <millis_timer_overflow_count+0x2>
 3a2:	b0 91 7a 00 	lds	r27, 0x007A	; 0x80007a <millis_timer_overflow_count+0x3>
 3a6:	01 96       	adiw	r24, 0x01	; 1
 3a8:	a1 1d       	adc	r26, r1
 3aa:	b1 1d       	adc	r27, r1
 3ac:	80 93 77 00 	sts	0x0077, r24	; 0x800077 <millis_timer_overflow_count>
 3b0:	90 93 78 00 	sts	0x0078, r25	; 0x800078 <millis_timer_overflow_count+0x1>
 3b4:	a0 93 79 00 	sts	0x0079, r26	; 0x800079 <millis_timer_overflow_count+0x2>
 3b8:	b0 93 7a 00 	sts	0x007A, r27	; 0x80007a <millis_timer_overflow_count+0x3>
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:336
#endif
  }
 3bc:	bf 91       	pop	r27
 3be:	af 91       	pop	r26
 3c0:	9f 91       	pop	r25
 3c2:	8f 91       	pop	r24
 3c4:	3f 91       	pop	r19
 3c6:	2f 91       	pop	r18
 3c8:	0f 90       	pop	r0
 3ca:	0f be       	out	0x3f, r0	; 63
 3cc:	0f 90       	pop	r0
 3ce:	1f 90       	pop	r1
 3d0:	18 95       	reti
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:328
      f -= FRACT_MAX;
      m += MILLIS_INC + 1;
    }
    else
    {
      m += MILLIS_INC;
 3d2:	02 96       	adiw	r24, 0x02	; 2
 3d4:	a1 1d       	adc	r26, r1
 3d6:	b1 1d       	adc	r27, r1
 3d8:	d4 cf       	rjmp	.-88     	; 0x382 <__vector_5+0x3c>

000003da <__vector_2>:
__vector_2():
C:\Program Files (x86)\Arduino\libraries\PinChangeInterrupt\src/PinChangeInterrupt0.cpp:40

void attachPinChangeInterrupt0(void) {
	// fake function to make the IDE link this file
}

ISR(PCINT0_vect) {
 3da:	1f 92       	push	r1
 3dc:	0f 92       	push	r0
 3de:	0f b6       	in	r0, 0x3f	; 63
 3e0:	0f 92       	push	r0
 3e2:	11 24       	eor	r1, r1
 3e4:	2f 93       	push	r18
 3e6:	3f 93       	push	r19
 3e8:	4f 93       	push	r20
 3ea:	5f 93       	push	r21
 3ec:	6f 93       	push	r22
 3ee:	7f 93       	push	r23
 3f0:	8f 93       	push	r24
 3f2:	9f 93       	push	r25
 3f4:	af 93       	push	r26
 3f6:	bf 93       	push	r27
 3f8:	cf 93       	push	r28
 3fa:	ef 93       	push	r30
 3fc:	ff 93       	push	r31
C:\Program Files (x86)\Arduino\libraries\PinChangeInterrupt\src/PinChangeInterrupt0.cpp:42
	// get the new and old pin states for port
	uint8_t newPort = PCINT_INPUT_PORT0;
 3fe:	86 b3       	in	r24, 0x16	; 22
C:\Program Files (x86)\Arduino\libraries\PinChangeInterrupt\src/PinChangeInterrupt0.cpp:52
	uint8_t rising = change & newPort;
	uint8_t falling = change & oldPorts[arrayPos];

	// check which pins are triggered, compared with the settings
	uint8_t risingTrigger = rising & risingPorts[arrayPos];
	uint8_t fallingTrigger = falling & fallingPorts[arrayPos];
 400:	c0 91 7b 00 	lds	r28, 0x007B	; 0x80007b <oldPorts>
 404:	90 91 7c 00 	lds	r25, 0x007C	; 0x80007c <fallingPorts>
 408:	c9 23       	and	r28, r25
 40a:	98 2f       	mov	r25, r24
 40c:	90 95       	com	r25
 40e:	c9 23       	and	r28, r25
C:\Program Files (x86)\Arduino\libraries\PinChangeInterrupt\src/PinChangeInterrupt0.cpp:56
	uint8_t trigger = risingTrigger | fallingTrigger;

	// save the new state for next comparison
	oldPorts[arrayPos] = newPort;
 410:	80 93 7b 00 	sts	0x007B, r24	; 0x80007b <oldPorts>
C:\Program Files (x86)\Arduino\libraries\PinChangeInterrupt\src/PinChangeInterrupt0.cpp:63
	// Execute all functions that should be triggered
	// This way we can exclude a single function
	// and the calling is also much faster
	// We may also reorder the pins for different priority
#if !defined(PCINT_CALLBACK_PORT0)
	PCINT_CALLBACK(0, 0);
 414:	c0 ff       	sbrs	r28, 0
 416:	05 c0       	rjmp	.+10     	; 0x422 <__LOCK_REGION_LENGTH__+0x22>
PinChangeInterruptEventPCINT0():
C:\Program Files (x86)\Arduino\libraries\PinChangeInterrupt\src/PinChangeInterrupt0.cpp:99
}
*/
#if (PCINT_USE_PCINT0 == true)
volatile callback callbackPCINT0 = pcint_null_callback;
void PinChangeInterruptEventPCINT0(void) {
	callbackPCINT0();
 418:	e0 91 60 00 	lds	r30, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 41c:	f0 91 61 00 	lds	r31, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 420:	09 95       	icall
__vector_2():
C:\Program Files (x86)\Arduino\libraries\PinChangeInterrupt\src/PinChangeInterrupt0.cpp:64
	// This way we can exclude a single function
	// and the calling is also much faster
	// We may also reorder the pins for different priority
#if !defined(PCINT_CALLBACK_PORT0)
	PCINT_CALLBACK(0, 0);
	PCINT_CALLBACK(1, 1);
 422:	c1 ff       	sbrs	r28, 1
 424:	05 c0       	rjmp	.+10     	; 0x430 <__LOCK_REGION_LENGTH__+0x30>
PinChangeInterruptEventPCINT1():
C:\Program Files (x86)\Arduino\libraries\PinChangeInterrupt\src/PinChangeInterrupt0.cpp:105
}
#endif
#if (PCINT_USE_PCINT1 == true)
volatile callback callbackPCINT1 = pcint_null_callback;
void PinChangeInterruptEventPCINT1(void) {
	callbackPCINT1();
 426:	e0 91 6a 00 	lds	r30, 0x006A	; 0x80006a <callbackPCINT1>
 42a:	f0 91 6b 00 	lds	r31, 0x006B	; 0x80006b <callbackPCINT1+0x1>
 42e:	09 95       	icall
__vector_2():
C:\Program Files (x86)\Arduino\libraries\PinChangeInterrupt\src/PinChangeInterrupt0.cpp:65
	// and the calling is also much faster
	// We may also reorder the pins for different priority
#if !defined(PCINT_CALLBACK_PORT0)
	PCINT_CALLBACK(0, 0);
	PCINT_CALLBACK(1, 1);
	PCINT_CALLBACK(2, 2);
 430:	c2 ff       	sbrs	r28, 2
 432:	05 c0       	rjmp	.+10     	; 0x43e <__LOCK_REGION_LENGTH__+0x3e>
PinChangeInterruptEventPCINT2():
C:\Program Files (x86)\Arduino\libraries\PinChangeInterrupt\src/PinChangeInterrupt0.cpp:111
}
#endif
#if (PCINT_USE_PCINT2 == true)
volatile callback callbackPCINT2 = pcint_null_callback;
void PinChangeInterruptEventPCINT2(void) {
	callbackPCINT2();
 434:	e0 91 62 00 	lds	r30, 0x0062	; 0x800062 <callbackPCINT2>
 438:	f0 91 63 00 	lds	r31, 0x0063	; 0x800063 <callbackPCINT2+0x1>
 43c:	09 95       	icall
__vector_2():
C:\Program Files (x86)\Arduino\libraries\PinChangeInterrupt\src/PinChangeInterrupt0.cpp:66
	// We may also reorder the pins for different priority
#if !defined(PCINT_CALLBACK_PORT0)
	PCINT_CALLBACK(0, 0);
	PCINT_CALLBACK(1, 1);
	PCINT_CALLBACK(2, 2);
	PCINT_CALLBACK(3, 3);
 43e:	c3 ff       	sbrs	r28, 3
 440:	05 c0       	rjmp	.+10     	; 0x44c <__LOCK_REGION_LENGTH__+0x4c>
PinChangeInterruptEventPCINT3():
C:\Program Files (x86)\Arduino\libraries\PinChangeInterrupt\src/PinChangeInterrupt0.cpp:117
}
#endif
#if (PCINT_USE_PCINT3 == true)
volatile callback callbackPCINT3 = pcint_null_callback;
void PinChangeInterruptEventPCINT3(void) {
	callbackPCINT3();
 442:	e0 91 64 00 	lds	r30, 0x0064	; 0x800064 <callbackPCINT3>
 446:	f0 91 65 00 	lds	r31, 0x0065	; 0x800065 <callbackPCINT3+0x1>
 44a:	09 95       	icall
__vector_2():
C:\Program Files (x86)\Arduino\libraries\PinChangeInterrupt\src/PinChangeInterrupt0.cpp:67
#if !defined(PCINT_CALLBACK_PORT0)
	PCINT_CALLBACK(0, 0);
	PCINT_CALLBACK(1, 1);
	PCINT_CALLBACK(2, 2);
	PCINT_CALLBACK(3, 3);
	PCINT_CALLBACK(4, 4);
 44c:	c4 ff       	sbrs	r28, 4
 44e:	05 c0       	rjmp	.+10     	; 0x45a <__LOCK_REGION_LENGTH__+0x5a>
PinChangeInterruptEventPCINT4():
C:\Program Files (x86)\Arduino\libraries\PinChangeInterrupt\src/PinChangeInterrupt0.cpp:123
}
#endif
#if (PCINT_USE_PCINT4 == true)
volatile callback callbackPCINT4 = pcint_null_callback;
void PinChangeInterruptEventPCINT4(void) {
	callbackPCINT4();
 450:	e0 91 66 00 	lds	r30, 0x0066	; 0x800066 <callbackPCINT4>
 454:	f0 91 67 00 	lds	r31, 0x0067	; 0x800067 <callbackPCINT4+0x1>
 458:	09 95       	icall
__vector_2():
C:\Program Files (x86)\Arduino\libraries\PinChangeInterrupt\src/PinChangeInterrupt0.cpp:68
	PCINT_CALLBACK(0, 0);
	PCINT_CALLBACK(1, 1);
	PCINT_CALLBACK(2, 2);
	PCINT_CALLBACK(3, 3);
	PCINT_CALLBACK(4, 4);
	PCINT_CALLBACK(5, 5);
 45a:	c5 ff       	sbrs	r28, 5
 45c:	05 c0       	rjmp	.+10     	; 0x468 <__LOCK_REGION_LENGTH__+0x68>
PinChangeInterruptEventPCINT5():
C:\Program Files (x86)\Arduino\libraries\PinChangeInterrupt\src/PinChangeInterrupt0.cpp:129
}
#endif
#if (PCINT_USE_PCINT5 == true)
volatile callback callbackPCINT5 = pcint_null_callback;
void PinChangeInterruptEventPCINT5(void) {
	callbackPCINT5();
 45e:	e0 91 68 00 	lds	r30, 0x0068	; 0x800068 <callbackPCINT5>
 462:	f0 91 69 00 	lds	r31, 0x0069	; 0x800069 <callbackPCINT5+0x1>
 466:	09 95       	icall
__vector_2():
C:\Program Files (x86)\Arduino\libraries\PinChangeInterrupt\src/PinChangeInterrupt0.cpp:74
	PCINT_CALLBACK(6, 6);
	PCINT_CALLBACK(7, 7);
#else
	PCINT_CALLBACK_PORT0
#endif
}
 468:	ff 91       	pop	r31
 46a:	ef 91       	pop	r30
 46c:	cf 91       	pop	r28
 46e:	bf 91       	pop	r27
 470:	af 91       	pop	r26
 472:	9f 91       	pop	r25
 474:	8f 91       	pop	r24
 476:	7f 91       	pop	r23
 478:	6f 91       	pop	r22
 47a:	5f 91       	pop	r21
 47c:	4f 91       	pop	r20
 47e:	3f 91       	pop	r19
 480:	2f 91       	pop	r18
 482:	0f 90       	pop	r0
 484:	0f be       	out	0x3f, r0	; 63
 486:	0f 90       	pop	r0
 488:	1f 90       	pop	r1
 48a:	18 95       	reti

0000048c <main>:
main():
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1138
*/

  // Use the Millis Timer for fast PWM (unless it doesn't have an output).
  #if (TIMER_TO_USE_FOR_MILLIS == 0)
    #if defined(WGM01) // if Timer0 has PWM
      TCCR0A = (1<<WGM01) | (1<<WGM00);
 48c:	83 e0       	ldi	r24, 0x03	; 3
 48e:	8a bd       	out	0x2a, r24	; 42
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1141
    #endif
    #if defined(TCCR0B) //The x61 has a wacky Timer0!
      TCCR0B = (MillisTimer_Prescale_Index << CS00);
 490:	83 bf       	out	0x33, r24	; 51
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1162
    TCCR1A = 1<<WGM10;
    TCCR1B = (1<<WGM12) | (MillisTimer_Prescale_Index << CS10);
  #endif

  // this needs to be called before setup() or some functions won't work there
  sei();
 492:	78 94       	sei
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1167

  #ifndef DISABLEMILLIS
    // Enable the overflow interrupt (this is the basic system tic-toc for millis)
    #if defined(TIMSK) && defined(TOIE0) && (TIMER_TO_USE_FOR_MILLIS == 0)
      sbi(TIMSK, TOIE0);
 494:	89 b7       	in	r24, 0x39	; 57
 496:	82 60       	ori	r24, 0x02	; 2
 498:	89 bf       	out	0x39, r24	; 57
initToneTimerInternal():
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:958
    #elif defined(__AVR_ATtiny43__)
      TCCR1A = 3; //WGM 10=1, WGM11=1
      TCCR1B = 3; //prescaler of 64
    #elif (TIMER_TO_USE_FOR_TONE == 1) && defined(TCCR1) // ATtiny x5
      // Use the Tone Timer for fast PWM as phase correct not supported by this timer
      GTCCR = (1<<PWM1B);
 49a:	80 e4       	ldi	r24, 0x40	; 64
 49c:	8c bd       	out	0x2c, r24	; 44
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:959
      OCR1C = 0xFF; //Use 255 as the top to match with the others as this module doesn't have a 8bit PWM mode.
 49e:	8f ef       	ldi	r24, 0xFF	; 255
 4a0:	8d bd       	out	0x2d, r24	; 45
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:960
      TCCR1 = (1<<CTC1) | (1<<PWM1A) | (ToneTimer_Prescale_Index << CS10);
 4a2:	87 ec       	ldi	r24, 0xC7	; 199
 4a4:	80 bf       	out	0x30, r24	; 48
main():
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1214
  #if defined( INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER ) && INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER
    #if defined(ADCSRA)
      // set a2d prescale factor
      // ADCSRA = (ADCSRA & ~((1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0))) | (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
      // dude, this is being called on startup. We know that ADCSRA is 0! Why add a RMW cycle?!
      ADCSRA = (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
 4a6:	86 e8       	ldi	r24, 0x86	; 134
 4a8:	86 b9       	out	0x06, r24	; 6
setup():
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:231



void setup() {

  pinMode(LED1, OUTPUT);
 4aa:	61 e0       	ldi	r22, 0x01	; 1
 4ac:	84 e0       	ldi	r24, 0x04	; 4
 4ae:	fc de       	rcall	.-520    	; 0x2a8 <pinMode>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:232
  pinMode(LED2, OUTPUT);
 4b0:	61 e0       	ldi	r22, 0x01	; 1
 4b2:	83 e0       	ldi	r24, 0x03	; 3
 4b4:	f9 de       	rcall	.-526    	; 0x2a8 <pinMode>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:233
  digitalWrite(LED1, HIGH);
 4b6:	61 e0       	ldi	r22, 0x01	; 1
 4b8:	84 e0       	ldi	r24, 0x04	; 4
 4ba:	8d de       	rcall	.-742    	; 0x1d6 <digitalWrite>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:234
  digitalWrite(LED2, LOW);
 4bc:	60 e0       	ldi	r22, 0x00	; 0
 4be:	83 e0       	ldi	r24, 0x03	; 3
 4c0:	8a de       	rcall	.-748    	; 0x1d6 <digitalWrite>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:236
  
  pinMode(button.pin, INPUT_PULLUP);
 4c2:	62 e0       	ldi	r22, 0x02	; 2
 4c4:	80 91 7d 00 	lds	r24, 0x007D	; 0x80007d <button>
 4c8:	ef de       	rcall	.-546    	; 0x2a8 <pinMode>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:238

  pinMode(TILT_SENSOR, INPUT);
 4ca:	60 e0       	ldi	r22, 0x00	; 0
 4cc:	81 e0       	ldi	r24, 0x01	; 1
 4ce:	ec de       	rcall	.-552    	; 0x2a8 <pinMode>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:240

  pinMode(BUZZER, OUTPUT);
 4d0:	61 e0       	ldi	r22, 0x01	; 1
 4d2:	82 e0       	ldi	r24, 0x02	; 2
 4d4:	e9 de       	rcall	.-558    	; 0x2a8 <pinMode>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:241
  digitalWrite(BUZZER, LOW);
 4d6:	60 e0       	ldi	r22, 0x00	; 0
 4d8:	82 e0       	ldi	r24, 0x02	; 2
 4da:	7d de       	rcall	.-774    	; 0x1d6 <digitalWrite>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:243

  m_status = 0;
 4dc:	10 92 91 00 	sts	0x0091, r1	; 0x800091 <m_status+0x1>
 4e0:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <m_status>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:245
  
  n_interval = 1;
 4e4:	81 e0       	ldi	r24, 0x01	; 1
 4e6:	90 e0       	ldi	r25, 0x00	; 0
 4e8:	90 93 6d 00 	sts	0x006D, r25	; 0x80006d <n_interval+0x1>
 4ec:	80 93 6c 00 	sts	0x006C, r24	; 0x80006c <n_interval>
operator*():
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\EEPROM/EEPROM.h:53

    EERef( const int index )
        : index( index )                 {}

    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
 4f0:	90 e0       	ldi	r25, 0x00	; 0
 4f2:	80 e0       	ldi	r24, 0x00	; 0
 4f4:	72 d1       	rcall	.+740    	; 0x7da <eeprom_read_byte>
setup():
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:247

  if (EEPROM.read(0) != 255){
 4f6:	8f 3f       	cpi	r24, 0xFF	; 255
 4f8:	41 f0       	breq	.+16     	; 0x50a <main+0x7e>
operator*():
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\EEPROM/EEPROM.h:53
 4fa:	90 e0       	ldi	r25, 0x00	; 0
 4fc:	80 e0       	ldi	r24, 0x00	; 0
 4fe:	6d d1       	rcall	.+730    	; 0x7da <eeprom_read_byte>
setup():
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:248
    n_interval = EEPROM.read(0);
 500:	90 e0       	ldi	r25, 0x00	; 0
 502:	90 93 6d 00 	sts	0x006D, r25	; 0x80006d <n_interval+0x1>
 506:	80 93 6c 00 	sts	0x006C, r24	; 0x80006c <n_interval>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:251
  }
  
  countDown = (unsigned long) n_interval * 3600 * 1000L;
 50a:	c0 91 6c 00 	lds	r28, 0x006C	; 0x80006c <n_interval>
 50e:	d0 91 6d 00 	lds	r29, 0x006D	; 0x80006d <n_interval+0x1>
 512:	be 01       	movw	r22, r28
 514:	90 e0       	ldi	r25, 0x00	; 0
 516:	80 e0       	ldi	r24, 0x00	; 0
 518:	20 e8       	ldi	r18, 0x80	; 128
 51a:	3e ee       	ldi	r19, 0xEE	; 238
 51c:	46 e3       	ldi	r20, 0x36	; 54
 51e:	50 e0       	ldi	r21, 0x00	; 0
 520:	72 d1       	rcall	.+740    	; 0x806 <__mulsi3>
 522:	60 93 6e 00 	sts	0x006E, r22	; 0x80006e <countDown>
 526:	70 93 6f 00 	sts	0x006F, r23	; 0x80006f <countDown+0x1>
 52a:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <countDown+0x2>
 52e:	90 93 71 00 	sts	0x0071, r25	; 0x800071 <countDown+0x3>
notify_delay():
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:107
  digitalWrite(LED2, LOW);
}


void notify_delay(){
 if (n_interval != 255) {
 532:	cf 3f       	cpi	r28, 0xFF	; 255
 534:	d1 05       	cpc	r29, r1
 536:	09 f0       	breq	.+2      	; 0x53a <main+0xae>
 538:	a0 de       	rcall	.-704    	; 0x27a <notify_delay() [clone .part.2]>
attachPinChangeInterrupt():
C:\Program Files (x86)\Arduino\libraries\PinChangeInterrupt\src/PinChangeInterrupt.h:434
		if (pcintNum == 0)
			callbackPCINT0 = userFunc;
#endif
#if (PCINT_USE_PCINT1 == true)
		if (pcintNum == 1)
			callbackPCINT1 = userFunc;
 53a:	83 ea       	ldi	r24, 0xA3	; 163
 53c:	90 e0       	ldi	r25, 0x00	; 0
 53e:	90 93 6b 00 	sts	0x006B, r25	; 0x80006b <callbackPCINT1+0x1>
 542:	80 93 6a 00 	sts	0x006A, r24	; 0x80006a <callbackPCINT1>
C:\Program Files (x86)\Arduino\libraries\PinChangeInterrupt\src/PinChangeInterrupt.h:602

	// save settings related to mode and registers
	if (mode == CHANGE || mode == RISING)
		risingPorts[arrayPos] |= pcintMask;
	if (mode == CHANGE || mode == FALLING)
		fallingPorts[arrayPos] |= pcintMask;
 546:	80 91 7c 00 	lds	r24, 0x007C	; 0x80007c <fallingPorts>
 54a:	82 60       	ori	r24, 0x02	; 2
 54c:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <fallingPorts>
enablePinChangeInterruptHelper():
C:\Program Files (x86)\Arduino\libraries\PinChangeInterrupt\src/PinChangeInterrupt.cpp:104
void enablePinChangeInterruptHelper(const uint8_t pcintPort, const uint8_t pcintMask, const uint8_t arrayPos){
	// Update the old state to the actual state
	switch(pcintPort){
#ifdef PCINT_INPUT_PORT0_USED
		case 0:
			oldPorts[arrayPos] = PCINT_INPUT_PORT0;
 550:	86 b3       	in	r24, 0x16	; 22
 552:	80 93 7b 00 	sts	0x007B, r24	; 0x80007b <oldPorts>
C:\Program Files (x86)\Arduino\libraries\PinChangeInterrupt\src/PinChangeInterrupt.cpp:160
#endif
		}
	}
#endif
#elif defined(PCMSK)
	*(&PCMSK + pcintPort) |= pcintMask;
 556:	a9 9a       	sbi	0x15, 1	; 21
C:\Program Files (x86)\Arduino\libraries\PinChangeInterrupt\src/PinChangeInterrupt.cpp:171
#elif defined(GICR) /* e.g. ATmega162 */
	GICR |= (1  << (pcintPort + PCIE0));
#elif defined(GIMSK) && defined(PCIE0) /* e.g. ATtiny X4 */
	GIMSK |= (1  << (pcintPort + PCIE0));
#elif defined(GIMSK) && defined(PCIE) /* e.g. ATtiny X5 */
	GIMSK |= (1  << (pcintPort + PCIE));
 558:	8b b7       	in	r24, 0x3b	; 59
 55a:	80 62       	ori	r24, 0x20	; 32
 55c:	8b bf       	out	0x3b, r24	; 59
setup():
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:257

  notify_delay();

  attachPCINT(digitalPinToPCINT(TILT_SENSOR), irs_sub , FALLING);
  
  timer = millis(); 
 55e:	e7 dd       	rcall	.-1074   	; 0x12e <millis>
 560:	60 93 86 00 	sts	0x0086, r22	; 0x800086 <timer>
 564:	70 93 87 00 	sts	0x0087, r23	; 0x800087 <timer+0x1>
 568:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <timer+0x2>
 56c:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <timer+0x3>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:258
  timer_led_tilt = millis();
 570:	de dd       	rcall	.-1092   	; 0x12e <millis>
 572:	60 93 8a 00 	sts	0x008A, r22	; 0x80008a <timer_led_tilt>
 576:	70 93 8b 00 	sts	0x008B, r23	; 0x80008b <timer_led_tilt+0x1>
 57a:	80 93 8c 00 	sts	0x008C, r24	; 0x80008c <timer_led_tilt+0x2>
 57e:	90 93 8d 00 	sts	0x008D, r25	; 0x80008d <timer_led_tilt+0x3>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:259
  timer_buzzer = millis();
 582:	d5 dd       	rcall	.-1110   	; 0x12e <millis>
Handle_Config():
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:175
            button.counter = millis();
        }
        
        if (button.currentState == NOT_PRESSED) {    
            unsigned long currentMillis = millis();              
            if ( (currentMillis - button.counter >= shortPress) && !(currentMillis - button.counter >= longPress) )  {     
 584:	8c e9       	ldi	r24, 0x9C	; 156
 586:	c8 2e       	mov	r12, r24
 588:	dd 24       	eor	r13, r13
 58a:	da 94       	dec	r13
 58c:	ed 2c       	mov	r14, r13
 58e:	fd 2c       	mov	r15, r13
handleLongPress():
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:134
void handleLongPress() {
  
   if (m_status == 0) { 
     beepLong();
     blinkLong();   
     n_interval  = 1;  
 590:	c1 e0       	ldi	r28, 0x01	; 1
 592:	d0 e0       	ldi	r29, 0x00	; 0
Handle_Config():
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:162



void Handle_Config(){
  
   button.currentState = digitalRead(button.pin);
 594:	80 91 7d 00 	lds	r24, 0x007D	; 0x80007d <button>
 598:	ef dd       	rcall	.-1058   	; 0x178 <digitalRead>
 59a:	21 e0       	ldi	r18, 0x01	; 1
 59c:	89 2b       	or	r24, r25
 59e:	09 f4       	brne	.+2      	; 0x5a2 <main+0x116>
 5a0:	20 e0       	ldi	r18, 0x00	; 0
 5a2:	20 93 85 00 	sts	0x0085, r18	; 0x800085 <button+0x8>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:164
    
    if (button.currentState != button.prevState) {     
 5a6:	80 91 84 00 	lds	r24, 0x0084	; 0x800084 <button+0x7>
 5aa:	28 17       	cp	r18, r24
 5ac:	09 f4       	brne	.+2      	; 0x5b0 <main+0x124>
 5ae:	a0 c0       	rjmp	.+320    	; 0x6f0 <main+0x264>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:165
        delay(button.debounce); 
 5b0:	60 91 7e 00 	lds	r22, 0x007E	; 0x80007e <button+0x1>
 5b4:	70 91 7f 00 	lds	r23, 0x007F	; 0x80007f <button+0x2>
 5b8:	07 2e       	mov	r0, r23
 5ba:	00 0c       	add	r0, r0
 5bc:	88 0b       	sbc	r24, r24
 5be:	99 0b       	sbc	r25, r25
 5c0:	8d dd       	rcall	.-1254   	; 0xdc <delay>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:167
            
        button.currentState = digitalRead(button.pin);  
 5c2:	80 91 7d 00 	lds	r24, 0x007D	; 0x80007d <button>
 5c6:	d8 dd       	rcall	.-1104   	; 0x178 <digitalRead>
 5c8:	21 e0       	ldi	r18, 0x01	; 1
 5ca:	00 97       	sbiw	r24, 0x00	; 0
 5cc:	09 f4       	brne	.+2      	; 0x5d0 <main+0x144>
 5ce:	20 e0       	ldi	r18, 0x00	; 0
 5d0:	20 93 85 00 	sts	0x0085, r18	; 0x800085 <button+0x8>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:169
        
        if (button.currentState == PRESSED) {           
 5d4:	89 2b       	or	r24, r25
 5d6:	49 f4       	brne	.+18     	; 0x5ea <main+0x15e>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:170
            button.counter = millis();
 5d8:	aa dd       	rcall	.-1196   	; 0x12e <millis>
 5da:	60 93 80 00 	sts	0x0080, r22	; 0x800080 <button+0x3>
 5de:	70 93 81 00 	sts	0x0081, r23	; 0x800081 <button+0x4>
 5e2:	80 93 82 00 	sts	0x0082, r24	; 0x800082 <button+0x5>
 5e6:	90 93 83 00 	sts	0x0083, r25	; 0x800083 <button+0x6>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:173
        }
        
        if (button.currentState == NOT_PRESSED) {    
 5ea:	80 91 85 00 	lds	r24, 0x0085	; 0x800085 <button+0x8>
 5ee:	88 23       	and	r24, r24
 5f0:	09 f4       	brne	.+2      	; 0x5f4 <main+0x168>
 5f2:	7a c0       	rjmp	.+244    	; 0x6e8 <main+0x25c>
 5f4:	00 91 90 00 	lds	r16, 0x0090	; 0x800090 <m_status>
 5f8:	10 91 91 00 	lds	r17, 0x0091	; 0x800091 <m_status+0x1>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:174
            unsigned long currentMillis = millis();              
 5fc:	98 dd       	rcall	.-1232   	; 0x12e <millis>
 5fe:	4b 01       	movw	r8, r22
 600:	5c 01       	movw	r10, r24
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:175
            if ( (currentMillis - button.counter >= shortPress) && !(currentMillis - button.counter >= longPress) )  {     
 602:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <button+0x3>
 606:	90 91 81 00 	lds	r25, 0x0081	; 0x800081 <button+0x4>
 60a:	a0 91 82 00 	lds	r26, 0x0082	; 0x800082 <button+0x5>
 60e:	b0 91 83 00 	lds	r27, 0x0083	; 0x800083 <button+0x6>
 612:	a7 01       	movw	r20, r14
 614:	96 01       	movw	r18, r12
 616:	28 1b       	sub	r18, r24
 618:	39 0b       	sbc	r19, r25
 61a:	4a 0b       	sbc	r20, r26
 61c:	5b 0b       	sbc	r21, r27
 61e:	da 01       	movw	r26, r20
 620:	c9 01       	movw	r24, r18
 622:	88 0d       	add	r24, r8
 624:	99 1d       	adc	r25, r9
 626:	aa 1d       	adc	r26, r10
 628:	bb 1d       	adc	r27, r11
 62a:	8c 36       	cpi	r24, 0x6C	; 108
 62c:	97 40       	sbci	r25, 0x07	; 7
 62e:	a1 05       	cpc	r26, r1
 630:	b1 05       	cpc	r27, r1
 632:	70 f4       	brcc	.+28     	; 0x650 <main+0x1c4>
handleShortPress():
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:120




void handleShortPress() {
   if (m_status == 1) {
 634:	01 30       	cpi	r16, 0x01	; 1
 636:	11 05       	cpc	r17, r1
 638:	59 f4       	brne	.+22     	; 0x650 <main+0x1c4>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:121
     n_interval  = n_interval + 1;  
 63a:	80 91 6c 00 	lds	r24, 0x006C	; 0x80006c <n_interval>
 63e:	90 91 6d 00 	lds	r25, 0x006D	; 0x80006d <n_interval+0x1>
 642:	01 96       	adiw	r24, 0x01	; 1
 644:	90 93 6d 00 	sts	0x006D, r25	; 0x80006d <n_interval+0x1>
 648:	80 93 6c 00 	sts	0x006C, r24	; 0x80006c <n_interval>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:122
     beepShort(); 
 64c:	0b de       	rcall	.-1002   	; 0x264 <beepShort()>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:123
     blinkShort();
 64e:	ff dd       	rcall	.-1026   	; 0x24e <blinkShort()>
Handle_Config():
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:178
        if (button.currentState == NOT_PRESSED) {    
            unsigned long currentMillis = millis();              
            if ( (currentMillis - button.counter >= shortPress) && !(currentMillis - button.counter >= longPress) )  {     
                handleShortPress();                          
            }
            if ((currentMillis - button.counter >= longPress)) {    
 650:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <button+0x3>
 654:	90 91 81 00 	lds	r25, 0x0081	; 0x800081 <button+0x4>
 658:	a0 91 82 00 	lds	r26, 0x0082	; 0x800082 <button+0x5>
 65c:	b0 91 83 00 	lds	r27, 0x0083	; 0x800083 <button+0x6>
 660:	88 1a       	sub	r8, r24
 662:	99 0a       	sbc	r9, r25
 664:	aa 0a       	sbc	r10, r26
 666:	bb 0a       	sbc	r11, r27
 668:	40 ed       	ldi	r20, 0xD0	; 208
 66a:	84 16       	cp	r8, r20
 66c:	47 e0       	ldi	r20, 0x07	; 7
 66e:	94 06       	cpc	r9, r20
 670:	a1 04       	cpc	r10, r1
 672:	b1 04       	cpc	r11, r1
 674:	c8 f1       	brcs	.+114    	; 0x6e8 <main+0x25c>
handleLongPress():
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:131



void handleLongPress() {
  
   if (m_status == 0) { 
 676:	01 2b       	or	r16, r17
 678:	f1 f4       	brne	.+60     	; 0x6b6 <main+0x22a>
beepLong():
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:78
}



void beepLong(){
  digitalWrite(BUZZER, HIGH);
 67a:	61 e0       	ldi	r22, 0x01	; 1
 67c:	82 e0       	ldi	r24, 0x02	; 2
 67e:	ab dd       	rcall	.-1194   	; 0x1d6 <digitalWrite>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:79
  delay(500);
 680:	64 ef       	ldi	r22, 0xF4	; 244
 682:	71 e0       	ldi	r23, 0x01	; 1
 684:	80 e0       	ldi	r24, 0x00	; 0
 686:	90 e0       	ldi	r25, 0x00	; 0
 688:	29 dd       	rcall	.-1454   	; 0xdc <delay>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:80
  digitalWrite(BUZZER, LOW);
 68a:	60 e0       	ldi	r22, 0x00	; 0
 68c:	82 e0       	ldi	r24, 0x02	; 2
 68e:	a3 dd       	rcall	.-1210   	; 0x1d6 <digitalWrite>
blinkLong():
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:93
}



void blinkLong(){
  digitalWrite(LED2, HIGH);
 690:	61 e0       	ldi	r22, 0x01	; 1
 692:	83 e0       	ldi	r24, 0x03	; 3
 694:	a0 dd       	rcall	.-1216   	; 0x1d6 <digitalWrite>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:94
  delay(500);
 696:	64 ef       	ldi	r22, 0xF4	; 244
 698:	71 e0       	ldi	r23, 0x01	; 1
 69a:	80 e0       	ldi	r24, 0x00	; 0
 69c:	90 e0       	ldi	r25, 0x00	; 0
 69e:	1e dd       	rcall	.-1476   	; 0xdc <delay>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:95
  digitalWrite(LED2, LOW);
 6a0:	60 e0       	ldi	r22, 0x00	; 0
 6a2:	83 e0       	ldi	r24, 0x03	; 3
 6a4:	98 dd       	rcall	.-1232   	; 0x1d6 <digitalWrite>
handleLongPress():
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:134
void handleLongPress() {
  
   if (m_status == 0) { 
     beepLong();
     blinkLong();   
     n_interval  = 1;  
 6a6:	d0 93 6d 00 	sts	0x006D, r29	; 0x80006d <n_interval+0x1>
 6aa:	c0 93 6c 00 	sts	0x006C, r28	; 0x80006c <n_interval>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:135
     m_status = 1;
 6ae:	d0 93 91 00 	sts	0x0091, r29	; 0x800091 <m_status+0x1>
 6b2:	c0 93 90 00 	sts	0x0090, r28	; 0x800090 <m_status>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:138
   }
   
   if (m_status == 1 && n_interval > 1) {
 6b6:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <m_status>
 6ba:	90 91 91 00 	lds	r25, 0x0091	; 0x800091 <m_status+0x1>
 6be:	01 97       	sbiw	r24, 0x01	; 1
 6c0:	99 f4       	brne	.+38     	; 0x6e8 <main+0x25c>
 6c2:	00 91 6c 00 	lds	r16, 0x006C	; 0x80006c <n_interval>
 6c6:	10 91 6d 00 	lds	r17, 0x006D	; 0x80006d <n_interval+0x1>
 6ca:	02 30       	cpi	r16, 0x02	; 2
 6cc:	11 05       	cpc	r17, r1
 6ce:	60 f0       	brcs	.+24     	; 0x6e8 <main+0x25c>
notify_delay():
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:107
  digitalWrite(LED2, LOW);
}


void notify_delay(){
 if (n_interval != 255) {
 6d0:	0f 3f       	cpi	r16, 0xFF	; 255
 6d2:	11 05       	cpc	r17, r1
 6d4:	09 f0       	breq	.+2      	; 0x6d8 <main+0x24c>
 6d6:	d1 dd       	rcall	.-1118   	; 0x27a <notify_delay() [clone .part.2]>
operator=():
C:\Users\mirko\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\EEPROM/EEPROM.h:61
    //Assignment/write members.
    EERef &operator=( const EERef &ref ) { return *this = *ref; }
    #if  (defined(__AVR_ATtinyX41__) && F_CPU==16000000 && CLOCK_SOURCE==0)
      EERef &operator=( uint8_t in )       { return safe_eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    #else
      EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
 6d8:	60 2f       	mov	r22, r16
 6da:	90 e0       	ldi	r25, 0x00	; 0
 6dc:	80 e0       	ldi	r24, 0x00	; 0
 6de:	85 d0       	rcall	.+266    	; 0x7ea <eeprom_write_byte>
handleLongPress():
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:141
   }
   
   if (m_status == 1 && n_interval > 1) {
     notify_delay();
     EEPROM.write(0, n_interval);      
     m_status = 0;     
 6e0:	10 92 91 00 	sts	0x0091, r1	; 0x800091 <m_status+0x1>
 6e4:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <m_status>
Handle_Config():
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:183
            if ((currentMillis - button.counter >= longPress)) {    
                handleLongPress();
            }                 
        }  
                
        button.prevState = button.currentState;  
 6e8:	80 91 85 00 	lds	r24, 0x0085	; 0x800085 <button+0x8>
 6ec:	80 93 84 00 	sts	0x0084, r24	; 0x800084 <button+0x7>
Handle_Status():
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:194




void Handle_Status(){
  if (m_status == 0) { 
 6f0:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <m_status>
 6f4:	90 91 91 00 	lds	r25, 0x0091	; 0x800091 <m_status+0x1>
 6f8:	89 2b       	or	r24, r25
 6fa:	09 f0       	breq	.+2      	; 0x6fe <main+0x272>
 6fc:	59 c0       	rjmp	.+178    	; 0x7b0 <main+0x324>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:196
         
        if (power_status){ 
 6fe:	80 91 8f 00 	lds	r24, 0x008F	; 0x80008f <power_status>
 702:	88 23       	and	r24, r24
 704:	19 f0       	breq	.+6      	; 0x70c <main+0x280>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:197
         digitalWrite(LED1, LOW);  
 706:	60 e0       	ldi	r22, 0x00	; 0
 708:	84 e0       	ldi	r24, 0x04	; 4
 70a:	65 dd       	rcall	.-1334   	; 0x1d6 <digitalWrite>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:200
        }
    
        if (led_tilt_status){ 
 70c:	80 91 8e 00 	lds	r24, 0x008E	; 0x80008e <led_tilt_status>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:201
          digitalWrite(LED2, HIGH);      
 710:	61 e0       	ldi	r22, 0x01	; 1
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:200
         
        if (power_status){ 
         digitalWrite(LED1, LOW);  
        }
    
        if (led_tilt_status){ 
 712:	81 11       	cpse	r24, r1
 714:	01 c0       	rjmp	.+2      	; 0x718 <main+0x28c>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:203
          digitalWrite(LED2, HIGH);      
        }else {
          digitalWrite(LED2, LOW); 
 716:	60 e0       	ldi	r22, 0x00	; 0
 718:	83 e0       	ldi	r24, 0x03	; 3
 71a:	5d dd       	rcall	.-1350   	; 0x1d6 <digitalWrite>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:206
        }
    
        if (millis()- timer_led_tilt >=  10 ){     
 71c:	08 dd       	rcall	.-1520   	; 0x12e <millis>
 71e:	00 91 8a 00 	lds	r16, 0x008A	; 0x80008a <timer_led_tilt>
 722:	10 91 8b 00 	lds	r17, 0x008B	; 0x80008b <timer_led_tilt+0x1>
 726:	20 91 8c 00 	lds	r18, 0x008C	; 0x80008c <timer_led_tilt+0x2>
 72a:	30 91 8d 00 	lds	r19, 0x008D	; 0x80008d <timer_led_tilt+0x3>
 72e:	60 1b       	sub	r22, r16
 730:	71 0b       	sbc	r23, r17
 732:	82 0b       	sbc	r24, r18
 734:	93 0b       	sbc	r25, r19
 736:	6a 30       	cpi	r22, 0x0A	; 10
 738:	71 05       	cpc	r23, r1
 73a:	81 05       	cpc	r24, r1
 73c:	91 05       	cpc	r25, r1
 73e:	58 f0       	brcs	.+22     	; 0x756 <main+0x2ca>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:207
         led_tilt_status=false;
 740:	10 92 8e 00 	sts	0x008E, r1	; 0x80008e <led_tilt_status>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:208
         timer_led_tilt = millis();
 744:	f4 dc       	rcall	.-1560   	; 0x12e <millis>
 746:	60 93 8a 00 	sts	0x008A, r22	; 0x80008a <timer_led_tilt>
 74a:	70 93 8b 00 	sts	0x008B, r23	; 0x80008b <timer_led_tilt+0x1>
 74e:	80 93 8c 00 	sts	0x008C, r24	; 0x80008c <timer_led_tilt+0x2>
 752:	90 93 8d 00 	sts	0x008D, r25	; 0x80008d <timer_led_tilt+0x3>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:211
        }
    
        if ((millis() - timer) >= countDown) {  
 756:	eb dc       	rcall	.-1578   	; 0x12e <millis>
 758:	00 91 86 00 	lds	r16, 0x0086	; 0x800086 <timer>
 75c:	10 91 87 00 	lds	r17, 0x0087	; 0x800087 <timer+0x1>
 760:	20 91 88 00 	lds	r18, 0x0088	; 0x800088 <timer+0x2>
 764:	30 91 89 00 	lds	r19, 0x0089	; 0x800089 <timer+0x3>
 768:	60 1b       	sub	r22, r16
 76a:	71 0b       	sbc	r23, r17
 76c:	82 0b       	sbc	r24, r18
 76e:	93 0b       	sbc	r25, r19
 770:	00 91 6e 00 	lds	r16, 0x006E	; 0x80006e <countDown>
 774:	10 91 6f 00 	lds	r17, 0x006F	; 0x80006f <countDown+0x1>
 778:	20 91 70 00 	lds	r18, 0x0070	; 0x800070 <countDown+0x2>
 77c:	30 91 71 00 	lds	r19, 0x0071	; 0x800071 <countDown+0x3>
 780:	60 17       	cp	r22, r16
 782:	71 07       	cpc	r23, r17
 784:	82 07       	cpc	r24, r18
 786:	93 07       	cpc	r25, r19
 788:	08 f4       	brcc	.+2      	; 0x78c <main+0x300>
 78a:	04 cf       	rjmp	.-504    	; 0x594 <main+0x108>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:212
          power_status=false; 
 78c:	10 92 8f 00 	sts	0x008F, r1	; 0x80008f <power_status>
sleep():
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:57




void sleep() {
    digitalWrite(LED1, HIGH);  
 790:	61 e0       	ldi	r22, 0x01	; 1
 792:	84 e0       	ldi	r24, 0x04	; 4
 794:	20 dd       	rcall	.-1472   	; 0x1d6 <digitalWrite>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:58
    digitalWrite(LED2, LOW); 
 796:	60 e0       	ldi	r22, 0x00	; 0
 798:	83 e0       	ldi	r24, 0x03	; 3
 79a:	1d dd       	rcall	.-1478   	; 0x1d6 <digitalWrite>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:59
    set_sleep_mode(SLEEP_MODE_PWR_DOWN);    
 79c:	85 b7       	in	r24, 0x35	; 53
 79e:	87 7e       	andi	r24, 0xE7	; 231
 7a0:	80 61       	ori	r24, 0x10	; 16
 7a2:	85 bf       	out	0x35, r24	; 53
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:60
    sleep_enable();                        
 7a4:	85 b7       	in	r24, 0x35	; 53
 7a6:	80 62       	ori	r24, 0x20	; 32
 7a8:	85 bf       	out	0x35, r24	; 53
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:61
    sei();                                  
 7aa:	78 94       	sei
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:62
    sleep_cpu();                            
 7ac:	88 95       	sleep
 7ae:	f2 ce       	rjmp	.-540    	; 0x594 <main+0x108>
Handle_Status():
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:218
          //timer = millis();            
          sleep();    
        }
        
    }else {
      digitalWrite(LED1, HIGH);
 7b0:	61 e0       	ldi	r22, 0x01	; 1
 7b2:	84 e0       	ldi	r24, 0x04	; 4
 7b4:	10 dd       	rcall	.-1504   	; 0x1d6 <digitalWrite>
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:219
      digitalWrite(LED2, LOW); 
 7b6:	60 e0       	ldi	r22, 0x00	; 0
 7b8:	83 e0       	ldi	r24, 0x03	; 3
 7ba:	0d dd       	rcall	.-1510   	; 0x1d6 <digitalWrite>
 7bc:	eb ce       	rjmp	.-554    	; 0x594 <main+0x108>

000007be <_GLOBAL__sub_I_blinkInterval>:
_GLOBAL__sub_I_blinkInterval():
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:38
unsigned long timer_buzzer = 0;
unsigned long countDown = 1000L;



typedef struct Buttons {
 7be:	ed e7       	ldi	r30, 0x7D	; 125
 7c0:	f0 e0       	ldi	r31, 0x00	; 0
 7c2:	10 82       	st	Z, r1
 7c4:	8a e0       	ldi	r24, 0x0A	; 10
 7c6:	90 e0       	ldi	r25, 0x00	; 0
 7c8:	92 83       	std	Z+2, r25	; 0x02
 7ca:	81 83       	std	Z+1, r24	; 0x01
 7cc:	13 82       	std	Z+3, r1	; 0x03
 7ce:	14 82       	std	Z+4, r1	; 0x04
 7d0:	15 82       	std	Z+5, r1	; 0x05
 7d2:	16 82       	std	Z+6, r1	; 0x06
 7d4:	81 e0       	ldi	r24, 0x01	; 1
 7d6:	87 83       	std	Z+7, r24	; 0x07
D:\Lavori\Futura Elettronica\ShakePower\TimerRettrigerable/TimerRettrigerable.ino:275

    Handle_Config();

    Handle_Status();
       
}
 7d8:	08 95       	ret

000007da <eeprom_read_byte>:
eeprom_read_byte():
 7da:	e1 99       	sbic	0x1c, 1	; 28
 7dc:	fe cf       	rjmp	.-4      	; 0x7da <eeprom_read_byte>
 7de:	9f bb       	out	0x1f, r25	; 31
 7e0:	8e bb       	out	0x1e, r24	; 30
 7e2:	e0 9a       	sbi	0x1c, 0	; 28
 7e4:	99 27       	eor	r25, r25
 7e6:	8d b3       	in	r24, 0x1d	; 29
 7e8:	08 95       	ret

000007ea <eeprom_write_byte>:
eeprom_write_byte():
 7ea:	26 2f       	mov	r18, r22

000007ec <eeprom_write_r18>:
 7ec:	e1 99       	sbic	0x1c, 1	; 28
 7ee:	fe cf       	rjmp	.-4      	; 0x7ec <eeprom_write_r18>
 7f0:	1c ba       	out	0x1c, r1	; 28
 7f2:	9f bb       	out	0x1f, r25	; 31
 7f4:	8e bb       	out	0x1e, r24	; 30
 7f6:	2d bb       	out	0x1d, r18	; 29
 7f8:	0f b6       	in	r0, 0x3f	; 63
 7fa:	f8 94       	cli
 7fc:	e2 9a       	sbi	0x1c, 2	; 28
 7fe:	e1 9a       	sbi	0x1c, 1	; 28
 800:	0f be       	out	0x3f, r0	; 63
 802:	01 96       	adiw	r24, 0x01	; 1
 804:	08 95       	ret

00000806 <__mulsi3>:
__mulsi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:445
 806:	ee 27       	eor	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:446
 808:	ff 27       	eor	r31, r31

0000080a <__mulsi3_helper>:
__mulsi3_helper():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:451
 80a:	aa 27       	eor	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:452
 80c:	bb 27       	eor	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:453
 80e:	08 c0       	rjmp	.+16     	; 0x820 <__mulsi3_helper+0x16>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:457
 810:	a2 0f       	add	r26, r18
 812:	b3 1f       	adc	r27, r19
 814:	e4 1f       	adc	r30, r20
 816:	f5 1f       	adc	r31, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:460
 818:	22 0f       	add	r18, r18
 81a:	33 1f       	adc	r19, r19
 81c:	44 1f       	adc	r20, r20
 81e:	55 1f       	adc	r21, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:463
 820:	96 95       	lsr	r25
 822:	87 95       	ror	r24
 824:	77 95       	ror	r23
 826:	67 95       	ror	r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:465
 828:	98 f3       	brcs	.-26     	; 0x810 <__mulsi3_helper+0x6>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:467
 82a:	70 40       	sbci	r23, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:468
 82c:	a9 f7       	brne	.-22     	; 0x818 <__mulsi3_helper+0xe>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:469
 82e:	00 97       	sbiw	r24, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:470
 830:	99 f7       	brne	.-26     	; 0x818 <__mulsi3_helper+0xe>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:473
 832:	bd 01       	movw	r22, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:474
 834:	cf 01       	movw	r24, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:480
 836:	08 95       	ret

00000838 <__tablejump2__>:
__tablejump2__():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
 838:	ee 0f       	add	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
 83a:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
 83c:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
 83e:	f4 91       	lpm	r31, Z
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
 840:	e0 2d       	mov	r30, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
 842:	09 94       	ijmp

00000844 <_exit>:
exit():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 844:	f8 94       	cli

00000846 <__stop_program>:
__stop_program():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 846:	ff cf       	rjmp	.-2      	; 0x846 <__stop_program>
